#!/bin/sh
set -eu

me="${0##*/}"

die() {
	echo "$me: $1" >&2
	exit 1
}

clrscr() {
	printf "\x1b[2J" # clear screen
	printf "\x1b[H" # move cursor to upper left
}

setup() {
	# We don't need "more" util to stop after the last screen, only
	# between screenfuls. Per posix more _shall_ prompt on eof,
	# unless -e is given. Util-linux more obeys posix, so needs -e.
	# But busybox more does not and fails on -e.
	MORE_OPTS="-e" # posix
	more --help 2>&1 | grep -q '^ *-e' || MORE_OPTS= # busybox

	# use standard IFS
	IFS=" 	
"
}

terminal() {
	local taskdir

	taskdir="$1"
	rm -rf "$tmp"/*
	if [ -d "$taskdir"/workdir ]; then
		cp -a "$taskdir"/workdir "$tmp"
	else
		mkdir "$tmp"/workdir
	fi

	(cd "$tmp"/workdir;
		HISTFILE="$tmp"/history \
		PS1='$ ' \
		exec /bin/sh) || :
}

shuffle() {
	local item

	while IFS= read -r item; do
		echo "$RANDOM $item"
	done | sort | cut -d" " -f2-
}

# In shell to return a string from a function, it must be printed to
# stdout and then captured. When function has to also do user output,
# stdout is already occupied for returning a value. These functions let
# do user output to stderr, which is also connected to a terminal.
echo2() {
	echo "$@" >&2
}
printf2() {
	printf "$@" >&2
}

choose_from_history() {
	local hist num_hist solution

	hist=$(cat "$tmp"/history)
	num_hist=$(echo "$hist" | wc -l)
	echo2
	echo "$hist" | cat -n | more $MORE_OPTS >&2
	echo2
	while true; do
		if [ "$num_hist" -gt 1 ]; then
			printf2 "Номер команды [q - выход]: "
		else
			printf2 "Выбрать? [ENTER - да, q - выход]: "
		fi
		read -r solution || { echo2; echo2; return 0; }
		[ "$solution" = "q" ] && echo2 && return 0
		[ "$num_hist" -eq 1 ] && [ -z "$solution" ] && solution=1
		[ "$solution" -ge 1 ] 2>/dev/null || continue
		[ "$solution" -le "$num_hist" ] 2>/dev/null || continue
		break
	done
	# return chosen command with whitespace stripped from both ends
	echo "$hist" | head -n"$solution" | tail -1 | sed 's/^ *//; s/ *$//'
}

do_lesson() {
	local lesson_dir taskdir choices choice num_choices solution \
		correct correct_choice is_correct

	lesson_dir="$1"
	for taskdir in "$lesson_dir"/*; do
		[ -e "$taskdir" ] || die "$lesson_dir не содержит заданий"

		# print static part of task
		clrscr
		cat "$taskdir"/task
		echo

		# print dynamic part of task, do some preprocessing
		if [ -e "$taskdir"/choices ]; then
			correct=$(head -1 "$taskdir/choices")
			choices=$(shuffle <"$taskdir"/choices)
			[ "$(echo "$choices" | wc -l)" -gt 1 ] || die "$taskdir/choices должен содержать больше одного варианта ответа"
			num_choices=0
			while IFS= read -r choice; do
				echo "$((++num_choices))  $choice"
				[ "$choice" = "$correct" ] && correct_choice=$num_choices
			done <<-EOF
			$choices
			EOF
			echo
		else
			echo "Вы можете запустить терминал для поиска ответа"
			rm -rf "$tmp"/history
		fi

		# get solution from user
		while true; do
			if [ -e "$taskdir"/choices ]; then
				printf "Номер ответа [q - выход]: "
			elif [ -s "$tmp"/history ]; then
				printf "Ответ [h - история, t - терминал, q - выход]: "
			else
				printf "Ответ [t - терминал, q - выход]: "
			fi

			read -r solution || return 0
			[ "$solution" = "q" ] && return 0
			if [ -e "$taskdir"/choices ]; then
				[ "$solution" -ge 1 ] 2>/dev/null || continue
				[ "$solution" -le $num_choices ] 2>/dev/null || continue
				solution=$(echo "$choices" | head -n"$solution" | tail -1)
			elif [ "$solution" = "t" ]; then
				echo
				echo "Для выхода введите exit или нажмите Ctrl-D в пустой строке"
				rm -rf "$tmp"/history
				terminal "$taskdir"
				echo
				[ -s "$tmp"/history ] && echo "Вы можете выбрать ответ из истории команд терминала"
				continue
			elif [ -s "$tmp"/history ] && [ "$solution" = "h" ]; then
				solution=$(choose_from_history)
				[ -n "$solution" ] || continue
			fi
			break
		done

		# check solution
		is_correct=
		if [ -e "$taskdir"/choices ]; then
			[ "$solution" = "$correct" ] && is_correct=1
			correct="$correct_choice  $correct" # prepend number
		else
			if echo "$solution" | grep -qExf "$taskdir"/solution.regex; then
				is_correct=1
			else
				correct=$(cat "$taskdir"/solution)
			fi
		fi

		# print result
		if [ -n "$is_correct" ]; then
			echo "ПРАВИЛЬНО"
		else
			echo "ОШИБКА"
			echo "$correct"
		fi
		printf "Нажмите ENTER для продолжения"
		read
	done
}

level_dirs() {
	local lvldirs

	lvldirs=$(find levels -mindepth 1 -maxdepth 1 -type d)
	[ -n "$lvldirs" ] || die "уровни не найдены"
	echo "$lvldirs" | sort
}

# return path to storage file for level progress
# $1 - level dir
level_store() {
	local lvldir lvlname

	lvldir="$1"
	lvlname="${lvldir##*/}"
	lvlname="${lvlname#*-}" # remove ordering prefix
	echo "$profiledir/levels/$lvlname"
}

# search current level and return its dir
# expects list of course level dirs on stdin
current_level() {
	local current lvldir lvlstore

	current=
	while IFS= read -r lvldir; do
		lvlstore=$(level_store "$lvldir")
		# unfinished level contains number of finished lessons,
		# immediately becomes current
		if [ -s "$lvlstore" ]; then
			current="$lvldir"
			break
		fi
		# otherwise look for first level that is not started
		if ! [ -e "$lvlstore" ]; then
			[ -z "$current" ] && current="$lvldir"
		fi
	done
	echo "$current"
}

# return num of lessons for a level
# $1 - level dir
level_num_lessons() {
	local num_lessons

	num_lessons=$(find "$1" -mindepth 1 -maxdepth 1 -type d)
	[ -n "$num_lessons" ] || die "$1 не содержит уроков"
	echo "$num_lessons" | wc -l
}

# duplicate a char number of times
# $1 - number of times, $2 - char
dup() {
	printf "%*s" "$1" "" | tr " " "$2"
}

level_menu() {
	local lvldirs lvldir current lvlnum lvl lvlstore curmark \
		num_lessons fin_lessons progress lesson

	clrscr
	echo "         У Р О В Н И"
	echo "         ==========="
	echo
	echo " Уровень  Прогресс  Название"
	echo

	lvldirs=$(level_dirs)
	current=$(echo "$lvldirs" | current_level)
	lvlnum=0
	fin_lessons=0
	while IFS= read -r lvldir; do
		num_lessons=$(level_num_lessons "$lvldir")
		lvlnum=$((lvlnum + 1))
		lvlstore=$(level_store "$lvldir")
		curmark=" "
		if [ "$lvldir" = "$current" ]; then
			curmark="*"
			# current level is either previously unfinished
			# or not yet started
			if [ -e "$lvlstore" ]; then
				# unfinished - read num of finished lessons
				IFS= read -r fin_lessons <"$lvlstore"
				[ "$(wc -l <"$lvlstore")" -lt 2 ] || die "в $lvlstore должна быть одна строка"
				grep -qx '[1-7]' "$lvlstore" || die "в $lvlstore должно быть число завершённых уроков от 1 до 7"
				# if due to update total num of lessons
				# became less than or equal to lessons
				# already finished, mark last lesson as
				# unfinished, so level must be finished
				if [ "$num_lessons" -le "$fin_lessons" ]; then
					fin_lessons=$((num_lessons - 1))
				fi
				progress="$(dup "$fin_lessons" "#")$(dup "$((num_lessons - fin_lessons))" "-")"
			else
				# not started - mark all lessons unfinished
				progress=$(dup "$num_lessons" "-")
			fi
		else
			# non-current level is either already finished
			# or not yet started
			if [ -e "$lvlstore" ]; then
				# finished - mark all lessons finished
				progress=$(dup "$num_lessons" "#")
			else
				# not started - mark all lessons locked
				progress=$(dup "$num_lessons" "x")
			fi
		fi
		printf "%s%7d  %-8s  %s\n" "$curmark" $lvlnum "$progress" "${lvlstore##*/}"
	done <<-EOF
	$lvldirs
	EOF

	echo
	while true; do
		if [ -n "$current" ]; then
			printf "Уровень [ENTER - текущий, q - выход]: "
		else
			printf "Уровень [q - выход]: "
		fi
		read -r lvl || { echo; exit 0; } # exit on EOF
		[ "$lvl" = "q" ] && exit 0
		if [ -z "$lvl" ]; then
			# ENTER pressed, no level chosen
			# this only makes sense for current level
			[ -n "$current" ] || continue
			lvldir="$current"
			lesson=$((fin_lessons + 1))
			break
		else
			# level number entered, check it, get level dir
			[ "$lvl" -ge 1 ] 2>/dev/null || continue
			[ "$lvl" -le $lvlnum ] 2>/dev/null || continue
			lvldir=$(echo "$lvldirs" | head -n"$lvl" | tail -1)

			# empty current level means course is done
			# some finished level is repeated - do it
			if [ -z "$current" ]; then
				lesson=$(level_num_lessons "$lvldir")
				break
			fi

			# course is not done, current level chosen - do it
			if [ "$lvldir" = "$current" ]; then
				lesson=$((fin_lessons + 1))
				break
			fi

			# either finished or not started level chosen
			lvlstore=$(level_store "$lvldir")
			# level is finished - do it
			if [ -e "$lvlstore" ]; then
				lesson=$(level_num_lessons "$lvldir")
				break
			fi
			# level is not started - locked
			echo "Уровень пока недоступен"
		fi
	done
	do_lesson "$lvldir/$lesson"
}

profiledir="$HOME"/.termgrasp
tmp=$(mktemp -dt termgrasp.XXXXXX)
setup
while true; do
	level_menu
done
