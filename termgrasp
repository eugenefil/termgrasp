#!/bin/sh
set -eu

me="${0##*/}"

die() {
	echo "$me: $1" >&2
	exit 1
}

clrscr() {
	printf "\x1b[2J" # clear screen
	printf "\x1b[H" # move cursor to upper left
}

play_level() {
	local lvldir

	lvldir="$1"
	for taskdir in "$lvldir"/*; do
		[ -d "$taskdir" ] || continue
		clrscr
		cat "$taskdir"/task
		echo

		rm -rf "$tmp"/*
		if [ -d "$taskdir"/workdir ]; then
			cp -a "$taskdir"/workdir "$tmp"
		else
			mkdir "$tmp"/workdir
		fi

		(cd "$tmp"/workdir;
			HISTFILE="$tmp"/history \
			PS1='$ ' \
			exec /bin/sh) || :

		# Read last command from shell history - this is user's
		# solution. Note, history file may be absent if there
		# were no commands. In this case just ignore open error,
		# solution is empty string. Remove leading and trailing
		# spaces from solution.
		lastcmd=$(tail -1 "$tmp"/history 2>/dev/null |
			sed 's/^ *//; s/ *$//')
		if echo "$lastcmd" | grep -qExf "$taskdir"/solution.regex; then
			echo "ПРАВИЛЬНО"
		else
			echo "ОШИБКА"
			cat "$taskdir"/solution
		fi
		printf "Нажмите ENTER для продолжения"
		read
	done
}

level_dirs() {
	local lvldirs

	lvldirs=$(find levels -mindepth 1 -maxdepth 1 -type d)
	[ -n "$lvldirs" ] || die "уровни не найдены"
	echo "$lvldirs" | sort
}

# search current level and return its dir
# expects list of course level dirs on stdin
current_level() {
	local current lvldir lvl

	current=
	while IFS= read -r lvldir; do
		lvl="${lvldir##*/}"
		lvl="${lvl#*-}" # remove ordering prefix

		# unfinished level contains number of finished lessons,
		# immediately becomes current
		if [ -s "$profiledir/levels/$lvl" ]; then
			current="$lvldir"
			break
		fi
		# otherwise look for first level that is not started
		if ! [ -e "$profiledir/levels/$lvl" ]; then
			[ -z "$current" ] && current="$lvldir"
		fi
	done
	echo "$current"
}

# duplicate a char number of times
# $1 - number of times, $2 - char
dup() {
	printf "%*s" "$1" "" | tr " " "$2"
}

level_menu() {
	local lvldirs lvldir current lvlnum lvl lvlstat curmark \
		num_lessons fin_lessons progress

	clrscr
	echo "         У Р О В Н И"
	echo "         ==========="
	echo
	echo " Уровень  Прогресс  Название"
	echo

	lvldirs=$(level_dirs)
	current=$(echo "$lvldirs" | current_level)
	lvlnum=0
	while IFS= read -r lvldir; do
		num_lessons=$(find "$lvldir" -mindepth 1 -maxdepth 1 -type d)
		[ -n "$num_lessons" ] || die "$lvldir не содержит уроков"
		num_lessons=$(echo "$num_lessons" | wc -l)

		lvlnum=$((lvlnum + 1))
		lvl="${lvldir##*/}"
		lvl="${lvl#*-}" # remove ordering prefix
		lvlstat="$profiledir/levels/$lvl"
		curmark=" "
		if [ "$lvldir" = "$current" ]; then
			curmark="*"
			# current level is either previously unfinished
			# or not yet started
			if [ -e "$lvlstat" ]; then
				# unfinished - read num of finished lessons
				IFS= read -r fin_lessons <"$lvlstat"
				[ "$(wc -l "$lvlstat")" -lt 2 ] || die "в $lvlstat должна быть одна строка"
				grep -qx '[1-7]' "$lvlstat" || die "в $lvlstat должно быть число завершённых уроков от 1 до 7"
				# if due to update total num of lessons
				# became less than or equal to lessons
				# already finished, mark last lesson as
				# unfinished, so level must be finished
				if [ "$num_lessons" -le "$fin_lessons" ]; then
					fin_lessons=$((num_lessons - 1))
				fi
				progress="$(dup "$fin_lessons" "#")$(dup "$((num_lessons - fin_lessons))" "-")"
			else
				# not started - mark all lessons unfinished
				progress=$(dup "$num_lessons" "-")
			fi
		else
			# non-current level is either already finished
			# or not yet started
			if [ -e "$lvlstat" ]; then
				# finished - mark all lessons finished
				progress=$(dup "$num_lessons" "#")
			else
				# not started - mark all lessons locked
				progress=$(dup "$num_lessons" "x")
			fi
		fi
		printf "%s%7d  %-8s  %s\n" "$curmark" $lvlnum "$progress" "$lvl"
	done <<-EOF
	$lvldirs
	EOF

	echo
	while true; do
		if [ -n "$current" ]; then
			printf "Уровень [ENTER - текущий, q - выход]: "
		else
			printf "Уровень [q - выход]: "
		fi
		IFS=" " read -r lvl || exit 0 # exit on EOF
		[ "$lvl" = "q" ] && exit 0
		if [ -z "$lvl" ]; then
			# ENTER pressed, no level chosen
			# this only makes sense for current level
			[ -n "$current" ] || continue
			lvldir="$current"
			break
		else
			# level number entered, check it, get level dir
			[ "$lvl" -ge 1 ] 2>/dev/null || continue
			[ "$lvl" -le $lvlnum ] 2>/dev/null || continue
			lvldir=$(echo "$lvldirs" | head -n"$lvl" | tail -1)

			# empty current level means course is done
			# some finished level is repeated - do it
			[ -z "$current" ] && break

			# course is not done, current level chosen - do it
			[ "$lvldir" = "$current" ] && break

			# either finished or not started level chosen
			lvl="${lvldir##*/}"
			lvl="${lvl#*-}" # remove ordering prefix
			# level is finished - do it
			[ -e "$profiledir/levels/$lvl" ] && break
			# level is not started - locked
			echo "Уровень пока недоступен"
		fi
	done
	echo "$lvldir"
	exit 0
}

profiledir="$HOME"/.termgrasp
tmp=$(mktemp -dt termgrasp.XXXXXX)
while true; do
	level_menu
done
