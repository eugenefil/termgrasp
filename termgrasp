#!/bin/sh
set -eu

me="${0##*/}"

die() {
	echo "$me: $1" >&2
	exit 1
}

clrscr() {
	printf "\x1b[2J" # clear screen
	printf "\x1b[H" # move cursor to upper left
}

terminal() {
	local taskdir

	taskdir="$1"
	rm -rf "$tmp"/*
	if [ -d "$taskdir"/workdir ]; then
		cp -a "$taskdir"/workdir "$tmp"
	else
		mkdir "$tmp"/workdir
	fi

	(cd "$tmp"/workdir;
		HISTFILE="$tmp"/history \
		PS1='$ ' \
		exec /bin/sh) || :
}

shuffle() {
	local item

	while IFS= read -r item; do
		echo "$RANDOM $item"
	done | sort | cut -d" " -f2-
}

do_lesson() {
	local lesson_dir taskdir choices choice num_choices solution \
		correct correct_choice

	lesson_dir="$1"
	for taskdir in "$lesson_dir"/*; do
		[ -e "$taskdir" ] || die "$lesson_dir не содержит заданий"
		clrscr
		cat "$taskdir"/task
		echo

		if [ -e "$taskdir"/choices ]; then
			correct=$(head -1 "$taskdir/choices")
			choices=$(shuffle <"$taskdir"/choices)
			[ "$(echo "$choices" | wc -l)" -gt 1 ] || die "$taskdir/choices должен содержать больше одного варианта ответа"
			num_choices=0
			while IFS= read -r choice; do
				echo "$((++num_choices))  $choice"
				[ "$choice" = "$correct" ] && correct_choice=$num_choices
			done <<-EOF
			$choices
			EOF
			echo

			while true; do
				printf "Номер ответа [q - выход]: "
				IFS=" " read -r solution || return
				[ "$solution" = "q" ] && return
				[ "$solution" -ge 1 ] 2>/dev/null || continue
				[ "$solution" -le $num_choices ] 2>/dev/null || continue
				break
			done
			solution=$(echo "$choices" | head -n"$solution" | tail -1)
			if [ "$solution" = "$correct" ]; then
				echo "ПРАВИЛЬНО"
			else
				echo "ОШИБКА"
				echo "$correct_choice  $correct"
			fi
		else
			echo "Вы можете запустить терминал для поиска ответа"
			rm -rf "$tmp"/history
			while true; do
				if [ -s "$tmp"/history ]; then
					printf "Ответ [h - история, t - терминал, q - выход]: "
				else
					printf "Ответ [t - терминал, q - выход]: "
				fi
				IFS= read -r solution || return
				[ "$solution" = "q" ] && return
				if [ "$solution" = "t" ]; then
					echo
					echo "Для выхода введите exit или нажмите Ctrl-D в пустой строке"
					rm -rf "$tmp"/history
					terminal "$taskdir"
					echo
					[ -s "$tmp"/history ] && echo "Вы можете выбрать ответ из истории команд терминала"
					continue
				fi
				if [ -s "$tmp"/history ] && [ "$solution" = "h" ]; then
					hist=$(cat "$tmp"/history)		
					num_hist=$(echo "$hist" | wc -l)
					echo
					echo "$hist" | cat -n | more -e
					echo
					while true; do
						if [ "$num_hist" -gt 1 ]; then
							printf "Номер команды [q - выход]: "
						else
							printf "Выбрать? [ENTER - да, q - выход]: "
						fi
						IFS=" " read -r solution || { echo; echo; continue 2; }
						[ "$solution" = "q" ] && echo && continue 2
						[ "$num_hist" -eq 1 ] && [ -z "$solution" ] && solution=1
						[ "$solution" -ge 1 ] 2>/dev/null || continue
						[ "$solution" -le "$num_hist" ] 2>/dev/null || continue
						break
					done
					solution=$(echo "$hist" | head -n"$solution" | tail -1 | sed 's/^ *//; s/ *$//')
				fi	
				break
			done
			if echo "$solution" | grep -qExf "$taskdir"/solution.regex; then
				echo "ПРАВИЛЬНО"
			else
				echo "ОШИБКА"
				cat "$taskdir"/solution
			fi
		fi
		printf "Нажмите ENTER для продолжения"
		read
	done
}

level_dirs() {
	local lvldirs

	lvldirs=$(find levels -mindepth 1 -maxdepth 1 -type d)
	[ -n "$lvldirs" ] || die "уровни не найдены"
	echo "$lvldirs" | sort
}

# search current level and return its dir
# expects list of course level dirs on stdin
current_level() {
	local current lvldir lvl

	current=
	while IFS= read -r lvldir; do
		lvl="${lvldir##*/}"
		lvl="${lvl#*-}" # remove ordering prefix

		# unfinished level contains number of finished lessons,
		# immediately becomes current
		if [ -s "$profiledir/levels/$lvl" ]; then
			current="$lvldir"
			break
		fi
		# otherwise look for first level that is not started
		if ! [ -e "$profiledir/levels/$lvl" ]; then
			[ -z "$current" ] && current="$lvldir"
		fi
	done
	echo "$current"
}

# return num of lessons for a level
# $1 - level dir
level_num_lessons() {
	local num_lessons

	num_lessons=$(find "$1" -mindepth 1 -maxdepth 1 -type d)
	[ -n "$num_lessons" ] || die "$1 не содержит уроков"
	echo "$num_lessons" | wc -l
}

# duplicate a char number of times
# $1 - number of times, $2 - char
dup() {
	printf "%*s" "$1" "" | tr " " "$2"
}

level_menu() {
	local lvldirs lvldir current lvlnum lvl lvlstat curmark \
		num_lessons fin_lessons progress lesson

	clrscr
	echo "         У Р О В Н И"
	echo "         ==========="
	echo
	echo " Уровень  Прогресс  Название"
	echo

	lvldirs=$(level_dirs)
	current=$(echo "$lvldirs" | current_level)
	lvlnum=0
	fin_lessons=0
	while IFS= read -r lvldir; do
		num_lessons=$(level_num_lessons "$lvldir")
		lvlnum=$((lvlnum + 1))
		lvl="${lvldir##*/}"
		lvl="${lvl#*-}" # remove ordering prefix
		lvlstat="$profiledir/levels/$lvl"
		curmark=" "
		if [ "$lvldir" = "$current" ]; then
			curmark="*"
			# current level is either previously unfinished
			# or not yet started
			if [ -e "$lvlstat" ]; then
				# unfinished - read num of finished lessons
				IFS= read -r fin_lessons <"$lvlstat"
				[ "$(wc -l <"$lvlstat")" -lt 2 ] || die "в $lvlstat должна быть одна строка"
				grep -qx '[1-7]' "$lvlstat" || die "в $lvlstat должно быть число завершённых уроков от 1 до 7"
				# if due to update total num of lessons
				# became less than or equal to lessons
				# already finished, mark last lesson as
				# unfinished, so level must be finished
				if [ "$num_lessons" -le "$fin_lessons" ]; then
					fin_lessons=$((num_lessons - 1))
				fi
				progress="$(dup "$fin_lessons" "#")$(dup "$((num_lessons - fin_lessons))" "-")"
			else
				# not started - mark all lessons unfinished
				progress=$(dup "$num_lessons" "-")
			fi
		else
			# non-current level is either already finished
			# or not yet started
			if [ -e "$lvlstat" ]; then
				# finished - mark all lessons finished
				progress=$(dup "$num_lessons" "#")
			else
				# not started - mark all lessons locked
				progress=$(dup "$num_lessons" "x")
			fi
		fi
		printf "%s%7d  %-8s  %s\n" "$curmark" $lvlnum "$progress" "$lvl"
	done <<-EOF
	$lvldirs
	EOF

	echo
	while true; do
		if [ -n "$current" ]; then
			printf "Уровень [ENTER - текущий, q - выход]: "
		else
			printf "Уровень [q - выход]: "
		fi
		IFS=" " read -r lvl || exit 0 # exit on EOF
		[ "$lvl" = "q" ] && exit 0
		if [ -z "$lvl" ]; then
			# ENTER pressed, no level chosen
			# this only makes sense for current level
			[ -n "$current" ] || continue
			lvldir="$current"
			lesson=$((fin_lessons + 1))
			break
		else
			# level number entered, check it, get level dir
			[ "$lvl" -ge 1 ] 2>/dev/null || continue
			[ "$lvl" -le $lvlnum ] 2>/dev/null || continue
			lvldir=$(echo "$lvldirs" | head -n"$lvl" | tail -1)

			# empty current level means course is done
			# some finished level is repeated - do it
			if [ -z "$current" ]; then
				lesson=$(level_num_lessons "$lvldir")
				break
			fi

			# course is not done, current level chosen - do it
			if [ "$lvldir" = "$current" ]; then
				lesson=$((fin_lessons + 1))
				break
			fi

			# either finished or not started level chosen
			lvl="${lvldir##*/}"
			lvl="${lvl#*-}" # remove ordering prefix
			# level is finished - do it
			if [ -e "$profiledir/levels/$lvl" ]; then
				lesson=$(level_num_lessons "$lvldir")
				break
			fi
			# level is not started - locked
			echo "Уровень пока недоступен"
		fi
	done
	do_lesson "$lvldir/$lesson"
}

profiledir="$HOME"/.termgrasp
tmp=$(mktemp -dt termgrasp.XXXXXX)
while true; do
	level_menu
done
