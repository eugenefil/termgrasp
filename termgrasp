#!/bin/sh
set -eu

me="${0##*/}"

die() {
	echo "$me: $1" >&2
	exit 1
}

clrscr() {
	printf "\033[2J" # clear screen
	printf "\033[H" # move cursor to upper left
}

urandom() {
	local n

	n=$(od -An -N2 -tu2 /dev/urandom)
	echo $n # no quotes - remove leading spaces
}

random_env() {
	echo "$RANDOM"
}

setup() {
	# We don't need "more" util to stop after the last screen, only
	# between screenfuls. Per posix more _shall_ prompt on eof,
	# unless -e is given. Util-linux more obeys posix, so needs -e.
	# But busybox more does not and fails on -e.
	MORE_OPTS="-e" # posix
	more --help 2>&1 | grep -q '^ *-e' || MORE_OPTS= # busybox

	# use standard IFS
	IFS=" 	
"

	# if shell does not support $RANDOM, use /dev/urandom
	[ -n "${RANDOM:-}" ] && RND=random_env || RND=urandom
}

terminal() {
	local taskdir

	taskdir="$1"
	rm -rf "$tmp"/*
	if [ -d "$taskdir"/workdir ]; then
		cp -a "$taskdir"/workdir "$tmp"
	else
		mkdir "$tmp"/workdir
	fi

	(cd "$tmp"/workdir;
		HISTFILE="$tmp"/history \
		PS1='$ ' \
		exec /bin/sh) || :
}

shuffle() {
	local item rnd

	while IFS= read -r item; do
		rnd=$($RND)
		echo "$rnd $item"
	done | sort | cut -d" " -f2-
}

# In shell to return a string from a function, it must be printed to
# stdout and then captured. When function has to also do user output,
# stdout is already occupied for returning a value. These functions let
# do user output to stderr, which is also connected to a terminal.
echo2() {
	echo "$@" >&2
}
printf2() {
	printf "$@" >&2
}

# return true if x is in range [a;b]
# $1 - x, $2 - a, $3 - b
check_range() {
	[ "$1" -ge "$2" ] 2>/dev/null || return 1
	[ "$1" -le "$3" ] 2>/dev/null || return 1
}

prompt_init() {
	# init global vars used by prompt_* functions
	prompt_text=
	prompt_commands=
	prompt_descriptions=
}

prompt_set() {
	prompt_text="$1"
}

prompt_addcmd() {
	local cmd long_desc short_desc

	cmd="$1"
	long_desc="${2-}"
	short_desc="${3-}"
	[ -n "$long_desc" ] && prompt_descriptions="$prompt_descriptions
$cmd - $long_desc"
	[ -n "$short_desc" ] && cmd="$cmd - $short_desc"
	prompt_commands="$prompt_commands,$cmd"
}

prompt_show() {
	prompt_descriptions="${prompt_descriptions#?}"
	[ -n "$prompt_descriptions" ] && echo "$prompt_descriptions"
	printf "%s [%s]: " "$prompt_text" "${prompt_commands#?}"
}

choose_from_shell_history() {
	local hist num_hist input

	hist=$(cat "$tmp"/history)
	num_hist=$(echo "$hist" | wc -l)
	echo2
	echo "$hist" | cat -n | more $MORE_OPTS >&2
	echo2
	while true; do
		if [ "$num_hist" -gt 1 ]; then
			printf2 "Номер команды [q - выход]: "
		else
			printf2 "Выбрать? [ENTER - да, q - выход]: "
		fi
		read -r input || return 0
		[ "$input" = "q" ] && return 0
		[ "$num_hist" -eq 1 ] && [ -z "$input" ] && input=1
		check_range "$input" 1 "$num_hist" && break
	done
	# return chosen command with whitespace stripped from both ends
	echo "$hist" | head -n"$input" | tail -1 | sed 's/^ *//; s/ *$//'
}

# return num of lessons for a level
# $1 - level dir
level_num_lessons() {
	local num_lessons

	num_lessons=$(find "$1" -mindepth 1 -maxdepth 1 -type d)
	[ -n "$num_lessons" ] || die "$1 не содержит уроков"
	echo "$num_lessons" | wc -l
}

choices_init() {
	local taskdir choice

	taskdir="$1"

	# init global vars used by choices_* functions
	choices_values=$(shuffle <"$taskdir"/choices)
	choices_correct=$(head -1 "$taskdir/choices")
	choices_correct_idx=0
	choices_num=0
	while IFS= read -r choice; do
		choices_num=$((choices_num + 1))
		[ "$choice" = "$choices_correct" ] && choices_correct_idx=$choices_num
	done <<-EOF
	$choices_values
	EOF
	[ "$choices_num" -gt 1 ] || die "$taskdir/choices должен содержать больше одного варианта ответа"
}

choices_dynamic() {
	local i choice

	i=0
	while IFS= read -r choice; do
		i=$((i + 1))
		echo "$i  $choice"
	done <<-EOF
	$choices_values
	EOF
	echo
}

choices_prompt() {
	prompt_set "Номер ответа"
}

choices_validate() {
	check_range "$1" 1 "$choices_num"
}

choices_process() {
	:
}

choices_solution() {
	echo "$1"
}

choices_check() {
	[ "$1" -ne "$choices_correct_idx" ] || echo 1
}

choices_correct() {
	echo "$choices_correct_idx  $choices_correct"
}

cmdentry_init() {
	rm -rf "$tmp"/history
	
	# init global vars used by cmdentry_* functions
	cmdentry_command=
}

cmdentry_dynamic() {
	:
}

cmdentry_prompt() {
	prompt_set "Команда"
	[ -s "$tmp"/history ] && prompt_addcmd "h" "выбрать решение из истории команд терминала"
	prompt_addcmd "t" "запустить терминал для поиска решения"
}

cmdentry_validate() {
	[ -n "$1" ]
}

cmdentry_process() {
	local input taskdir

	input="$1"
	taskdir="$2"
	if [ "$input" = "t" ]; then
		echo2
		echo2 "Для выхода введите exit или нажмите Ctrl-D в пустой строке"
		terminal "$taskdir" >&2
	elif [ -s "$tmp"/history ] && [ "$input" = "h" ]; then
		cmdentry_command=$(choose_from_shell_history)
	else
		cmdentry_command="$input"
	fi
}

cmdentry_solution() {
	echo "$cmdentry_command"
}

cmdentry_check() {
	local ret

	ret=0
	echo "$1" | grep -Exf "$2"/solution.regex || ret=$?
	[ $ret -lt 2 ] || return $ret
}

cmdentry_correct() {
	cat "$1"/solution
}

cmdblocks_init() {
	local taskdir i blocks block

	# init global vars used by cmdblocks_* functions
	cmdblocks_avail_blocks=
	cmdblocks_chosen_blocks=

	taskdir="$1"
	blocks=$(shuffle <"$taskdir"/blocks)
	i=0
	while IFS= read -r block; do
		i=$((i + 1))
		if [ -z "$cmdblocks_avail_blocks" ]; then
			cmdblocks_avail_blocks="$i  $block"
		else
			cmdblocks_avail_blocks="$cmdblocks_avail_blocks
$i  $block"
		fi
	done <<-EOF
	$blocks
	EOF
	[ "$i" -gt 1 ] || die "$taskdir/blocks должен содержать больше одного блока"
}

cmdblocks_get_command() {
	local cmd i block

	cmd=
	while read -r i block; do
		cmd="$cmd $block"
	done <<-EOF
	$cmdblocks_chosen_blocks
	EOF
	cmd="${cmd# }" # strip leading space
	[ -n "$cmd" ] || cmd="<пусто>"
	echo "$cmd"
}

cmdblocks_dynamic() {
	echo "Команда: $(cmdblocks_get_command)"
	echo
	echo "$cmdblocks_avail_blocks"
	echo
}

cmdblocks_prompt() {
	prompt_set "Номер блока"
	if [ -n "$cmdblocks_chosen_blocks" ]; then
		prompt_addcmd "ENTER" "готово"
		prompt_addcmd "d" "удалить блок"
	fi
}

cmdblocks_validate() {
	local input i block

	input="$1"
	if [ -n "$cmdblocks_chosen_blocks" ]; then
		[ -z "$input" ] && return 0
		[ "$input" = "d" ] && return 0
	fi

	while read -r i block; do
		[ -z "$block" ] && continue
		[ "$i" -eq "$input" ] 2>/dev/null && return 0
	done <<-EOF
	$cmdblocks_avail_blocks
	EOF
	return 1
}

cmdblocks_delete_last_block() {
	local n last new_avail_blocks i block

	# delete last block from chosen blocks
	n=$(echo "$cmdblocks_chosen_blocks" | wc -l)
	n=$((n - 1))
	last=$(echo "$cmdblocks_chosen_blocks" | tail -1)
	cmdblocks_chosen_blocks=$(echo "$cmdblocks_chosen_blocks" | head -n"$n")

	# insert deleted block back into available blocks
	read -r n block <<-EOF
	$last
	EOF
	last="$block"
	new_avail_blocks=
	while read -r i block; do
		[ "$i" -eq "$n" ] && block="$last"
		if [ -z "$new_avail_blocks" ]; then
			new_avail_blocks="$i  $block"
		else
			new_avail_blocks="$new_avail_blocks
$i  $block"
		fi
	done <<-EOF
	$cmdblocks_avail_blocks
	EOF
	cmdblocks_avail_blocks="$new_avail_blocks"
}

cmdblocks_choose_block() {
	local choice new_avail_blocks i block

	choice="$1"
	new_avail_blocks=
	while read -r i block; do
		if [ "$i" -eq "$choice" ]; then
			if [ -z "$cmdblocks_chosen_blocks" ]; then
				cmdblocks_chosen_blocks="$i  $block"
			else
				cmdblocks_chosen_blocks="$cmdblocks_chosen_blocks
$i  $block"
			fi
			block= # clear this block in available blocks
		fi

		if [ -z "$new_avail_blocks" ]; then
			new_avail_blocks="$i  $block"
		else
			new_avail_blocks="$new_avail_blocks
$i  $block"
		fi
	done <<-EOF
	$cmdblocks_avail_blocks
	EOF
	cmdblocks_avail_blocks="$new_avail_blocks"
}

cmdblocks_process() {
	local input

	input="$1"
	if [ -z "$input" ]; then
		return 0 # command compositing is finished - just exit
	elif [ "$input" = "d" ]; then
		cmdblocks_delete_last_block
	else
		cmdblocks_choose_block "$input"
	fi
}

cmdblocks_solution() {
	# non-empty input means we're still composing the command
	[ -z "$1" ] || return 0
	cmdblocks_get_command
}

cmdblocks_check() {
	local ret

	ret=0
	echo "$1" | grep -Fxf "$2"/solution || ret=$?
	[ $ret -lt 2 ] || return $ret
}

cmdblocks_correct() {
	head -1 "$1"/solution
}

do_lesson() {
	local lvldir lesson taskdir tasktype input solution is_correct \
		num_lessons lvlstore newstore

	lvldir="$1"
	lesson="$2"
	for taskdir in "$lvldir/$lesson"/*; do
		[ -e "$taskdir" ] || die "$lvldir/$lesson не содержит заданий"

		if [ -e "$taskdir"/choices ]; then
			tasktype=choices
		elif [ -e "$taskdir"/blocks ]; then
			tasktype=cmdblocks
		else
			tasktype=cmdentry
		fi

		${tasktype}_init "$taskdir"

		solution=
		while [ -z "$solution" ]; do
			# print static part of task
			clrscr
			cat "$taskdir"/task
			echo

			# print dynamic part of task
			${tasktype}_dynamic

			# get input from user
			while true; do
				# print prompt
				prompt_init
				${tasktype}_prompt
				prompt_addcmd "q" "" "выход"
				prompt_show

				# read and validate input
				read -r input || return 0
				[ "$input" = "q" ] && return 0
				${tasktype}_validate "$input" && break
			done
			
			# process input
			${tasktype}_process "$input" "$taskdir"

			# obtain solution (note, subshell is used, so
			# var assignments in *_solution func are not
			# persistent - use *_process above for that)
			solution=$(${tasktype}_solution "$input")
		done

		# check solution
		is_correct=$(${tasktype}_check "$solution" "$taskdir")

		# print result
		if [ -n "$is_correct" ]; then
			echo "ПРАВИЛЬНО"
		else
			echo "ОШИБКА"
			${tasktype}_correct "$taskdir"
		fi
		printf "Нажмите ENTER для продолжения"
		read -r input || :
	done

	# lesson finished, save progress
	num_lessons=$(level_num_lessons "$lvldir")
	lvlstore=$(level_store "$lvldir")
	newstore=$(mktemp)
	# if level is finished, write empty string to level progress
	# file, otherwise write num of currently finished lessons
	[ "$lesson" -lt "$num_lessons" ] && echo "$lesson" >"$newstore"
	mkdir -p "${lvlstore%/*}"
	mv "$newstore" "$lvlstore"
}

level_dirs() {
	local lvldirs

	lvldirs=$(find levels -mindepth 1 -maxdepth 1 -type d)
	[ -n "$lvldirs" ] || die "уровни не найдены"
	echo "$lvldirs" | sort
}

# return path to storage file for level progress
# $1 - level dir
level_store() {
	local lvldir lvlname

	lvldir="$1"
	lvlname="${lvldir##*/}"
	lvlname="${lvlname#*-}" # remove ordering prefix
	echo "$profiledir/levels/$lvlname"
}

# search current level and return its dir
# expects list of course level dirs on stdin
current_level() {
	local current lvldir lvlstore

	current=
	while IFS= read -r lvldir; do
		lvlstore=$(level_store "$lvldir")
		# unfinished level contains number of finished lessons,
		# immediately becomes current
		if [ -s "$lvlstore" ]; then
			current="$lvldir"
			break
		fi
		# otherwise look for first level that is not started
		if ! [ -e "$lvlstore" ]; then
			[ -z "$current" ] && current="$lvldir"
		fi
	done
	echo "$current"
}

# duplicate a char number of times
# $1 - number of times, $2 - char
dup() {
	printf "%*s" "$1" "" | tr " " "$2"
}

level_menu() {
	local lvldirs lvldir current lvlnum lvl lvlstore curmark \
		num_lessons fin_lessons progress lesson

	clrscr
	echo "       У Р О В Н И"
	echo "       ==========="
	echo
	echo " Номер  Прогресс  Название"
	echo

	lvldirs=$(level_dirs)
	current=$(echo "$lvldirs" | current_level)
	lvlnum=0
	fin_lessons=0
	while IFS= read -r lvldir; do
		num_lessons=$(level_num_lessons "$lvldir")
		lvlnum=$((lvlnum + 1))
		lvlstore=$(level_store "$lvldir")
		curmark=" "
		if [ "$lvldir" = "$current" ]; then
			curmark="*"
			# current level is either previously unfinished
			# or not yet started
			if [ -e "$lvlstore" ]; then
				# unfinished - read num of finished lessons
				IFS= read -r fin_lessons <"$lvlstore"
				[ "$(wc -l <"$lvlstore")" -lt 2 ] || die "в $lvlstore должна быть одна строка"
				grep -qx '[1-7]' "$lvlstore" || die "в $lvlstore должно быть число завершённых уроков от 1 до 7"
				# if due to update total num of lessons
				# became less than or equal to lessons
				# already finished, mark last lesson as
				# unfinished, so level must be finished
				if [ "$num_lessons" -le "$fin_lessons" ]; then
					fin_lessons=$((num_lessons - 1))
				fi
				progress="$(dup "$fin_lessons" "#")$(dup "$((num_lessons - fin_lessons))" "-")"
			else
				# not started - mark all lessons unfinished
				progress=$(dup "$num_lessons" "-")
			fi
		else
			# non-current level is either already finished
			# or not yet started
			if [ -e "$lvlstore" ]; then
				# finished - mark all lessons finished
				progress=$(dup "$num_lessons" "#")
			else
				# not started - mark all lessons locked
				progress=$(dup "$num_lessons" "x")
			fi
		fi
		printf "%s%5d  %-8s  %s\n" "$curmark" $lvlnum "$progress" "${lvlstore##*/}"
	done <<-EOF
	$lvldirs
	EOF

	echo
	while true; do
		if [ -n "$current" ]; then
			printf "Номер уровня [ENTER - текущий, q - выход]: "
		else
			printf "Номер уровня [q - выход]: "
		fi
		read -r lvl || { echo; exit 0; } # exit on EOF
		[ "$lvl" = "q" ] && exit 0
		if [ -z "$lvl" ]; then
			# ENTER pressed, no level chosen
			# this only makes sense for current level
			[ -n "$current" ] || continue
			lvldir="$current"
			lesson=$((fin_lessons + 1))
			break
		else
			# level number entered, check it, get level dir
			check_range "$lvl" 1 $lvlnum || continue
			lvldir=$(echo "$lvldirs" | head -n"$lvl" | tail -1)

			# empty current level means course is done
			# some finished level is repeated - do it
			if [ -z "$current" ]; then
				lesson=$(level_num_lessons "$lvldir")
				break
			fi

			# course is not done, current level chosen - do it
			if [ "$lvldir" = "$current" ]; then
				lesson=$((fin_lessons + 1))
				break
			fi

			# either finished or not started level chosen
			lvlstore=$(level_store "$lvldir")
			# level is finished - do it
			if [ -e "$lvlstore" ]; then
				lesson=$(level_num_lessons "$lvldir")
				break
			fi
			# level is not started - locked
			echo "Уровень пока недоступен"
		fi
	done
	do_lesson "$lvldir" "$lesson"
}

profiledir="$HOME"/.termgrasp
tmp=$(mktemp -dt termgrasp.XXXXXX)
setup
while true; do
	level_menu
done
